// Copyright (C) 2022-2024 Webb Technologies Inc.
//
// Tangle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tangle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should receive a copy of the GNU General Public License
// If not, see <http://www.gnu.org/licenses/>.

#![warn(missing_docs)]
//! # Relayer Proposal Signing Backends ðŸ•¸ï¸
//!
//! ## Overview
//! This crate contains the proposal signing backends for the relayer.
//! Proposal signing backends are used to sign the proposals that are generated by the relayer.
//! There are two types of proposal signing backends:
//! - `MockedProposalSigningBackend`: This is a mocked proposal signing backend that is used for testing purposes.
//! - `SigningRulesBackend`: This is the actual proposal signing backend that is used in production.
//!
//! This crate also contains the proposal queue that is used to queue the proposals that are generated by the relayer.

use std::{ops, sync::Arc};
use tokio::sync::Mutex;
use webb::evm::ethers::contract::Contract;
use webb::evm::{
    contract::protocol_dkg::signing_rules::SigningRulesContract,
    ethers::providers::Middleware,
};
use webb_proposals::ProposalTrait;
/// A module to handle proposals
#[doc(hidden)]
pub mod proposal_handler;

#[doc(hidden)]
pub mod dkg;

#[doc(hidden)]
pub mod mocked;

/// A module to handle the queue of proposals
pub mod queue;

/// A module that Implements the DKG Proposal Signing Backend.
pub use dkg::*;
/// A module that Implements the Mocked Proposal Signing Backend.
pub use mocked::*;
use webb_relayer_config::signing_backend::DkgProposalSigningBackendConfig;
use webb_relayer_utils::metric;

/// A Proposal Signing Backend is responsible for signing proposal `P` where `P` is anything really depending on the
/// requirement of the user of this backend.
///
/// As of now, we have two implementations of this trait:
///
/// - `DkgSigningBackend`: This is using the `DKG` protocol to sign the proposal.
/// - `MockedSigningBackend`: This is using the Governor's `PrivateKey` to sign the proposal directly.
#[async_trait::async_trait]
pub trait ProposalSigningBackend {
    /// A method to be called first to check if this backend can handle this proposal or not.
    async fn can_handle_proposal(
        &self,
        proposal: &(impl ProposalTrait + Sync + Send + 'static),
    ) -> webb_relayer_utils::Result<bool>;
    /// Send the Unsigned Proposal to the backend to start handling the signing process.
    async fn handle_proposal(
        &self,
        proposal: &(impl ProposalTrait + Sync + Send + 'static),
        metrics: Arc<Mutex<metric::Metrics>>,
    ) -> webb_relayer_utils::Result<()>;
}

/// SigningRulesContractWrapper around SigningRulesContract
#[derive(Clone, Debug)]
pub struct SigningRulesContractWrapper<M>
where
    M: Middleware,
{
    /// Signing rules contract config.
    pub config: DkgProposalSigningBackendConfig,
    /// Contratc
    pub contract: SigningRulesContract<M>,
}

impl<M> SigningRulesContractWrapper<M>
where
    M: Middleware,
{
    /// Creates wrapper around SigningRulesContract.
    pub fn new(
        config: DkgProposalSigningBackendConfig,
        client: Arc<M>,
    ) -> Self {
        Self {
            contract: SigningRulesContract::new(config.address, client),
            config,
        }
    }
}

impl<M> ops::Deref for SigningRulesContractWrapper<M>
where
    M: Middleware,
{
    type Target = Contract<M>;

    fn deref(&self) -> &Self::Target {
        &self.contract
    }
}
