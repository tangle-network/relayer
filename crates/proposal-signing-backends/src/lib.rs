// Copyright 2022 Webb Technologies Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![warn(missing_docs)]
//! # Relayer Proposal Signing Backends ðŸ•¸ï¸
//!
//! ## Overview
//! This crate contains the proposal signing backends for the relayer.
//! Proposal signing backends are used to sign the proposals that are generated by the relayer.
//! There are two types of proposal signing backends:
//! - `MockedProposalSigningBackend`: This is a mocked proposal signing backend that is used for testing purposes.
//! - `DKGProposalSigningBackend`: This is the actual proposal signing backend that is used in production.
//!
//! This crate also contains the proposal queue that is used to queue the proposals that are generated by the relayer.

use std::{ops, sync::Arc};
use tokio::sync::Mutex;
use webb::evm::ethers::contract::Contract;
use webb::evm::{
    contract::protocol_dkg::signing_rules::SigningRulesContract,
    ethers::providers::Middleware,
};
use webb_proposals::ProposalTrait;
/// A module to handle proposals
#[doc(hidden)]
pub mod proposal_handler;

#[doc(hidden)]
pub mod dkg;

#[doc(hidden)]
pub mod mocked;

/// A module to handle the queue of proposals
pub mod queue;

/// A module that Implements the DKG Proposal Signing Backend.
pub use dkg::*;
/// A module that Implements the Mocked Proposal Signing Backend.
pub use mocked::*;
use webb_relayer_utils::metric;

/// A Proposal Signing Backend is responsible for signing proposal `P` where `P` is anything really depending on the
/// requirement of the user of this backend.
///
/// As of now, we have two implementations of this trait:
///
/// - `DkgSigningBackend`: This is using the `DKG` protocol to sign the proposal.
/// - `MockedSigningBackend`: This is using the Governor's `PrivateKey` to sign the proposal directly.
#[async_trait::async_trait]
pub trait ProposalSigningBackend {
    /// A method to be called first to check if this backend can handle this proposal or not.
    async fn can_handle_proposal(
        &self,
        proposal: &(impl ProposalTrait + Sync + Send + 'static),
    ) -> webb_relayer_utils::Result<bool>;
    /// Send the Unsigned Proposal to the backend to start handling the signing process.
    async fn handle_proposal(
        &self,
        proposal: &(impl ProposalTrait + Sync + Send + 'static),
        metrics: Arc<Mutex<metric::Metrics>>,
    ) -> webb_relayer_utils::Result<()>;
}

/// SigningRulesContractWrapper around SigningRulesContract
#[derive(Clone, Debug)]
pub struct SigningRulesContractWrapper<M>
where
    M: Middleware,
{
    /// Signing rules contract config.
    pub config: webb_relayer_config::SigningRulesContractConfig,
    /// Contratc
    pub contract: SigningRulesContract<M>,
}

impl<M> SigningRulesContractWrapper<M>
where
    M: Middleware,
{
    /// Creates wrapper around SigningRulesContract.
    pub fn new(
        config: webb_relayer_config::SigningRulesContractConfig,
        client: Arc<M>,
    ) -> Self {
        Self {
            contract: SigningRulesContract::new(config.address, client),
            config,
        }
    }
}

impl<M> ops::Deref for SigningRulesContractWrapper<M>
where
    M: Middleware,
{
    type Target = Contract<M>;

    fn deref(&self) -> &Self::Target {
        &self.contract
    }
}
